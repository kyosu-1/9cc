# メモ

[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)を読んでいく中でのメモ

## 機械語とアセンブラ

### CPUとメモリ

* コンピュータを構成するコンポーネントは、大きくCPUとメモリにわけられる
  * メモリはデータを保持できるデバイス
  * CPUは、そのメモリを読み書きしながら何らかの処理を行なっていくデバイス
* CPUが実行するプログラムと、そのプログラムが読み書きするデータは、どちらもメモリに入っている
* CPUが実行するプログラムの形式そのもののことを「機械語」(machine code)という
* CPUはプログラムカウンタのほかにも、少数のデータ保存領域を持っており、この領域を「レジスタ」(register)と呼ぶ。
  * モリはCPUから見て外部の装置で、それを読み書きするには多少の時間がかかる一方で、レジスタはCPU内部に存在していて、遅延なしにアクセスすることが可能
* 多くの機械語は、2つのレジスタの値を使って何らかの演算を行なって、その結果をレジスタに書き戻すというフォーマットになっている
  * よってプログラムの実行というものは、CPUがメモリからレジスタにデータを読み込んできて、レジスタとレジスタの間でなんらかの演算を行い、その結果をメモリに書き戻す、ということで実行が進んでいくことになる
* 特定の機械語の命令を総称として「命令セットアーキテクチャ」（instruction set architecture, ISA）あるいは「命令セット」という


### アセンブラとは

* アセンブリは機械語にほぼそのまま1対1で対応するような言語だが、機械語よりもはるかに人間にとって読みやすいものになっている
* 仮想マシンやインタープリタではなくネイティブなバイナリを出力するコンパイラの場合、通常、アセンブリを出力することが目標になる
* アセンブリ→機械語への変換を「コンパイルする」 or 入力がアセンブリであることを強調して「アセンブルする」という
* `objdump -d -M intel /bin/ls`といったように`objdump`コマンドを使って適当な実行ファイルを逆アセンブルすることができる

アセンブリでは基本的に機械語1個につき1行という構成となっている。
例としてlsコマンドを逆アセンブルしたものの中から以下の次の行を見てみる。

```bash
3d58:  48 83 ec 08           sub    rsp,0x8
```

この行が意味するの以下の通り

1. 3d58というのは、機械語が入っているメモリのアドレスで、lsコマンドが実行されるとき、この行の命令はメモリの0x3d58番地に置かれるようになっていて、プログラムカウンタが0x3d58のときにこの命令が実行されることになる
2. その次に続いている4つの16進数の数値は実際の機械語で、CPUはこのデータを読んで、それを命令として実行する
3. sub rsp,0x8というのは、その機械語命令に対応するアセンブリであり、この命令は、RSPというレジスタから8を引く（subtract = 引く）という命令

### Cとそれに対応するアセンブラ

#### 単純な例

```c
int main() {
  return 42;
}
```

このようなCプログラムに対応するアセンブリプログラムは次の通り。(test1.c)

```s
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

このアセンブリでは、グローバルなラベルmainが定義されていて、ラベルのあとにmain関数のコードが続いている
。ここでは42という値を、RAXというレジスタにセットし、mainからリターンしている。整数を入れられるレジスタはRAXを含めて合計で16個あるが、関数からリターンしたときにRAXに入っている値が関数の返り値という約束になっているため、ここでは値をRAXにセットしている。


大雑把にいうと、Cコンパイラは、test1.cのようなCコードを読み込んだ時に、test2.sのようなアセンブリを出力するプログラムということになる。

#### 関数呼び出しを含む場合

* 関数呼び出しは単なるジャンプとは異なり、呼び出した関数が終了した後に、元々実行していた場所に戻ってこなければいけない
* 元々実行していたアドレスのことを「リターンアドレス」という
  * 関数呼び出しはいくらでも深くできるので、リターンアドレスはメモリに保存する必要がある
  * 実際にはリターンアドレスはメモリ上のスタックに保存される
* スタック
  * スタックの一番上のアドレスを保持する1つの変数のみを使って実装することが可能
  * そのスタックトップを保持している記憶領域のことを「スタックポインタ」という
  * x86-64は、関数を使ったプログラミングをサポートするために、スタックポインタ専用のレジスタと、そのレジスタを利用する命令をサポート
  * スタックにデータを積むことを「プッシュ」、スタックに積まれたデータを取り出すことを「ポップ」という

関数呼び出しの例

```c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```

このCコードに対応するアセンブリは次のようになる

```s
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

* 1行目はアセンブリの文法を指定する命令
* 2行目の.globlから始まる行は、plusとmainという2つの関数がファイルスコープではなくプログラム全体から見える関数だということをアセンブリに指示していいる
* mainについて
  * Cではmainからplusを引数つきで呼び出している
  * アセンブラにおいては、第一引数はRDIレジスタ、第二引数はRSIレジスタに入れるという約束になっているので、mainの最初の2行でそのとおりに値をセットしている
* callについて
  * callというのは関数を呼び出す命令
  * 具体的に次のようなことを行う
    * callの次の命令（この場合ret）のアドレスをスタックにプッシュ
    * callの引数として与えられたアドレスにジャンプ
  * call命令が実行されると、CPUはplus関数を実行し始めることになる
* plus関数について
  * plus関数には3つの命令がある
  * addは足し算を行う命令
    * この場合には、RSIレジスタとRDIレジスタを足した結果がRSIレジスタに書き込まれる
    * x86-64の整数演算命令は通常2つのレジスタしか受け取らないので、第1引数のレジスタの値を上書きする形で結果が保存される
  * 関数からの返り値はRAXに入れるということになっていた
    * よって足し算の結果はRAXに入れておきたいので、RSIからRAXに値をコピーする必要がある
    * ここではmov命令を使ってそれを行なっている
      * 実際にはデータを移動するわけではなく単にコピーする命令
  * plus関数の最後では、retを呼んで関数からリターンしている
    * 具体的にretは次のことを行う
      * スタックからアドレスを1つポップ
      * そのアドレスにジャンプ
    * つまりretは、callが行なったことを元に戻して、呼び出し元の関数の実行を再開する命令
      * このようにcallとretは対になる命令として定義されている
  * plusからリターンしたところにあるのはmainのret命令
    * 元のCコードではplusの返り値をそのままmainから返すということになっていた
    * ここではplusの返り値がRAXに入った状態になっているので、そのままmainからリターンすることで、それをそのままmainからの返り値にすることができる


### まとめ

* CPUはメモリを読み書きすることでプログラムの実行を進めていく
* CPUが実行するプログラムと、そのプログラムが扱うデータは、どちらもメモリに入っていて、CPUはメモリから順に機械語命令を読み、その命令を実行する
* CPUにはレジスタという小さな記憶領域があり、多くの機械語はレジスタ間での操作として定義されている
* アセンブリは機械語を人間にとって読みやすくした言語で、Cコンパイラは普通はアセンブリを出力する
* Cの関数はアセンブリでも関数になる
* 関数呼び出しはスタックを使って実装されている

